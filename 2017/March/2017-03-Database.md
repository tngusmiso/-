# 제 1과목_데이터베이스

* 관계 대수
    * 순수 관계연산자
        * 릴레이션을 처리하기 위한 연산
        * 피연산자도 릴레이션, 결과도 릴레이션
        * select, project, join, division
<br/><br/>

* SQL
    * Select 필드1,필드2,필드3
    * From 테이블1 (As) 별칭1, 테이블2 (As) 별칭2
    * Where 필드 = '조건' And 필드 = '조건'
<br/><br/>

* 후위 연산 표기법
    * 4 2 4 * + 2 / 3 +
    * ((4+(2*4))/2)+3
    * 답 : 9
<br/><br/>

* 뷰
    * 가상 테이블 (물리적 X)
    * 시스템 검색은 일반 테이블과 동일
    * 논리적 데이터 독립성을 제공
    * 하나의 뷰를 삭제하면 연관된 뷰도 자동 삭제
    * 접근 제한을 통해 보안 제공
    * 실제 데이터가 저장되지 않는다.
    * 독자적인 인덱스 가질 수 없음
    * 뷰를 이용한 또 다른 뷰의 생성이 가능하다(뷰는 다른 뷰를 대상으로 설정될 수 있다)
    * 필요한 데이터만 뷰로 정리해서 처리. 관리가 용이
    * 뷰는 변경 불가. 지우고 다시 만들어야 함
<br/><br/>

* 이진 트리
    * 깊이 : 최상위 노드부터 최하위 노드까지의 단계
    * 깊이 = 5 ; 1+2+4+8+16 = 31
<br/><br/>

* 로킹 기법
    * 상호 배제와 접근 제어 가능/ Lock을 건 트랜젝션만이 Lock을 해제할 수 있음
    * 로킹 단위
        * 로킹 단위가 커지면 -> 로크 수가 감소 -> 제어기법 간단 -> 병행성 감소
        * 로킹 단위가 작아지면 -> 로크수가 증가 -> 제어기법 복잡 -> 병행성 증가
    * 로크의 종류 
        * lock-S(shared, 공용 로크) : read만 가능
        * lock-X(exclusived, 전용 로크) : read, write
    * 2단계 로킹 규약
        * 확장 단계 : 새로운 lock 연산만 수행할 수 있고, unlock연산은 수행할 수 없는 단계
        * 축소 단계 : unlock만 수행할 수 있고, 일단 unlock 하면 lock은 할 수 없음
        * 2단계 로킹 준수??
            * 첫번째 unlock 전에 모든 lock이 수행되었다.
            * 직렬 가능
        * 교착상태 문제
<br/><br/>

* 스키마 (메타 데이터)
    * 데이터베이스의 구조와 제약사항을 묘사한 것
    * 개념적 스키마
        * 논리적 데이터 구조, 단순함
        * 조직 전체의 데이터 베이스로 하나만 존재
    * 외부 스키마
        * 공용보다는 개인이나 특정 응용에 한정
        * 데이터베이스에 접근하는 개별 사용자나 응용 프로그래머가 사용하는 데이터베이스
    * 내부 스키마
        * 데이터베이스에 실제 데이터가 저장되는것
        * 물리적 저장장치의 입장에서 본 데이터베이스 구조
    * 슈퍼 스키마
<br/><br/>

* 데이터베이스 설계
    * 요구 분석
    * 개념적 설계 : 개념 스키마 설계
        * 현실 세계에 대한 인식을 추상적 개념으로 표현
        * DBMS에 독립적인 E-R다이어그램으로 작성
        * 스키마 모델링과 트랜젝션 모델링
    * 논리적 설계 :
        * 현실세계의 개념을 물리적 저장장치에 저장할 수 있도록 DBMS가 지원하는 논리적 자료구조로 변환(종속적)
        * 트랜젝션 인터페이스 설계 / 테이블 설계
    * 물리적 설계
        * 저장 레코드 양식을 설계
        * 파일 조직 방법, 저장 방법, 접근 방법 등 선정
    * 데이터베이스 구현
<br/><br/>

* 정렬
    * 삽입정렬
        * 첫번째 ~ n번째 까지 비교하면서 하나씩 추가
    * 버블정렬
        * 인접해 있는 자료들 끼리 비교(두개씩)하여 자리 바꿈
        * 여러번의 회전 해야함
    * 선택정렬
        * n번째 자신과 나머지 모두를 비교하며 정렬
    * 퀵정렬
        * 임의의 값을 기준으로 작은값과 큰 값들을 옮긴다.
        * 그 파티션을 기준으로 같은 방법을 반복한다.
    * 셸정렬
        * 자료 리스트를 2차원 배열로 나열한다.
        * 각 배열의 열들을 정렬한다.
        * 한 열에 2 원소만 남아서 정리될 때 까지 반복한다.
        * 최종적으로 삽입정렬한다.
<br/><br/>

* DML(데이터조작어)
    * select
    * delete
    * insert
    * update
* DCL(데이터 제어어)
    * commit
    * rollback
    * grant
    * revoke
<br/><br/>

* 그래프의 인접행렬
    *   1 2 3 1 x x x 2 x x x 3 x x x
    * 1->3방향으로 표시되어 있는 경우, (1,3)좌표 값은 1
<br/><br/>

* 데이터 모델의 종류
    * 계층형 데이터 모델
        * 트리 형태
    * 네트워크형 데이터 모델
        * CODASYL DBTG
    * 개체-관계형 데이터 모델
        * ER다이어그램
<br/><br/>

* 트랜잭션의 특성
    * 원자성(Atomicity) : 모두 반영되거나 모두 반영되지 않거나
        * commit, rollback
    * 일관성(Consistency) : 언제나 일관성 있는 데이터 상태
    * 독립성(Isolation) : 다른 트랜잭션 실행 중에 끼어들 수 없음
    * 지속성(Durability) : 한번 성공적으로 나온 결과는 시스템 오류가 나더라도 지속되어야 한다.
<br/><br/>

* 시스템 카탈로그
    * 시스템 그 자체에 관련이 있는 스키마 및 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다. 
    * 자료사전, 메타데이터
    * 일반 이용자도 SQL을 이용하여 내용을 검색해 볼 수 있다/ 갱신 불가
    * DBMS가 자동 생성, 유지
<br/><br/>

* 릴레이션
    * 튜플은 서로 다른 값. 순서 없음
    * 속성은 유일한 이름
    * 모든 속성 값은 원자값
<br/><br/>

* 해싱
    * 키-주소 변환 방법, 직접 접근 방법(DAM)
    * 검색 속도 가장 빠르며, 삽입, 삭제 연산이 많을 때 유리
    * 충돌 해결
        * Chaining : 각 데이터를 해당 주소에 있는 링크드 리스트에 삽입하여 문제를 해결하는 방법
        * Open Addressing : 충돌이 일어나면 해시 테이블 내의 새로운 주소를 탐사(Probe)하여 충돌된 데이터를 입력하는 방식
<br/><br/>

* 무결성 제약 조건
    * 개체 무결성 : 기본 키
    * 참조 무결성 : 외래 키
    * 도메인 무결성 : 속성 값이 해당 도메인(자료형) 이어야 한다.
<br/><br/>

* E-R모델
    * 마름모 : 관계
    * 사각형 : 개체
    * 타원 : 속성
    * 이중 타원 : 다중값 속성
    * 밑줄 타원 : 기본키
<br/><br/>